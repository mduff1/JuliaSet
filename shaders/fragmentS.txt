#version 330 core
precision highp float;

in vec4 gl_FragCoord;
out vec4 fragColor;

uniform float time;
uniform vec2 resolution;
uniform vec2 cursorPos;

#define MAX_ITERATIONS 250
#define eR 1.0
#define zoom 3.0


float calc(vec2 z, vec2 c)
{
	for(int i = 0; i < MAX_ITERATIONS; i++)
	{
		float real = z.x * z.x - z.y * z.y + c.x;
		float imag = 2.0 * z.x * z.y + c.y;

		z.x = real;
		z.y = imag;

		if(dot(z, z) > eR)
		{
			float temp = float(i) - log2(log2(dot(z, z))) + 4.0;
			return temp / float(MAX_ITERATIONS);
		}
	}
	return 0.0;
}


float juliaCalc(vec2 coordinate, vec2 cursorPos)
{
	vec2 z = vec2(coordinate.x, coordinate.y);
	vec2 c = vec2(cursorPos.x, cursorPos.y);
	return calc(z, c);
}

vec2 coordScale(vec4 coord)
{
	vec2 relativePos = vec2(coord.xy / resolution.xy);
	vec2 actualPos   = (relativePos - 0.5) * zoom;

	float aspectRatio = resolution.x / resolution.y;
	actualPos.x *= aspectRatio;

	return actualPos;
}


void main()
{
	vec2 coord			 = coordScale(gl_FragCoord);
	vec2 actualCursorPos = coordScale(vec4(cursorPos, 0.0, 0.0));

	vec2 c = vec2(-1.0, 0.5); // cool location

	c.x *= cos(0.2 * time);
	c.y *= sin(0.2 * time);


	float juliaValue     = juliaCalc(coord, c);

	//vec3 color = vec3(0.5, 0.0, 0.0);
	//color += vec3(0.5 * cos(juliaValue * 6.2832 * 1.0 + vec3(0.0, 0.0, 0.0)));
	
	vec3 color = vec3(cos(3.0 + (juliaValue)* 25.0 + 0.0), 1.0 * cos(2.8 + (juliaValue) * 10.0 + 0.0), cos(3.0 + (juliaValue) * 25.0 + 1.0));
	fragColor = vec4(color, 1.0);
}